\documentclass{article}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{geometry}
\usepackage{caption}
\usepackage{indentfirst}

\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}}  
\usepackage{minted}
\usemintedstyle{autumn}
\setminted{linenos,breaklines,tabsize=4,xleftmargin=1.5em}

\geometry{left=3.0cm,right=3.0cm,top=3.0cm,bottom=4.0cm}
%\renewcommand{\thesection}{Ex. \arabic{section}}

\title{VE281 Project One Report}
\author{Liu Yihao 515370910207}
\date{}

\begin{document}
\maketitle

\section{Introduction}

In order to study the performances of these six sorting algorithms, I generated different size of arrays and compared the running speed of them (including the std::sort function in STL). Since it's a waste of time to wrote a comparison script written in C++, I chose node-gyp to build the sorting algorithm into a C++ addon of node, and then wrote some Javascript code to benchmark them. Small size of arrays were run for several times so that the result can be more accurate.

\section{Comparison of algorithms}

The limitation of runtime was set to 1s for all algorithms, so some meaningless and slow running were dropped (eg. large array size for bubble sort). Then I used MATLAB to plot two graphs, one of small test cases, and another of all cases.

\begin{figure}
%\includegraphics[width=0.8\linewidth]{../benchmark/}
\end{figure}


\section{Appendix}

The project 1 program files
\begin{enumerate}[(a)]
\item
sort.h
\inputminted{c++}{../answer/sort.h}
\item
sort.cpp
\inputminted{c++}{../answer/sort.cpp}
\item
main.cpp
\inputminted{c++}{../answer/main.cpp}
\end{enumerate}

The benchmark program
\inputminted{javascript}{../benchmark/benchmark.js}








\end{document}
